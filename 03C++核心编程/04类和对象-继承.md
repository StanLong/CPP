# C++核心编程

## 4 类和对象

### 4.6 继承

#### 4.6.1 继承的基本语法

```cpp
class A : public B;
```

A类称为子类或派生类。 B类称为父类或基类。

派生类中的成员包含两大部分， 一类是从基类继承过来的，一类是自己增加的成员。从基类继承过来的表现其共性，而新增的成员表现其个性。

```cpp
# include <iostream>
using namespace std;

// 继承的基本语法
class BasePage
{
    public:
    void header()
    {
        cout << "公共头" << endl;
    }

    void left()
    {
        cout << "公共侧边栏" << endl;
    }

    void footer()
    {
        cout << "公共链接" << endl;
    }

};

class Java : public BasePage
{
    public:
    void content()
    {
        cout << "Java页面的内容" << endl;
    }
};

class Python : public BasePage
{
    public:
    void content()
    {
        cout << "Python页面的内容" << endl;
    }
};



void test01()
{
    Java java;
    java.header();
    java.left();
    java.content();
    java.footer();

    Python python;
    python.header();
    python.left();
    python.content();
    python.footer();
}

int main(int argc, char *argv[])
{
    test01();
}
```

#### 4.6.2 继承方式

继承语法： `class 子类 : 继承方式 父类` 

继承方式一共有三种：

- 公共继承
- 保护继承
- 私有继承

```cpp
# include <iostream>
using namespace std;

class Base1
{
    public:
    int m_A;

    protected:
    int m_B;

    private:
    int m_C;
};

class Son1:public Base1
{
    public:
    void func()
    {
        m_A = 10; // 父类中的公共权限成员，到子类中依然是公共权限
        m_B = 10; // 父类中的保护权限成员，到子类中依然是保护权限
        // 父类中的私有权限成员，子中类访问不到
    }
};

class Son2:protected Base1
{
    public:
    void func()
    {
        m_A = 100; // 父类中公共成员，到子类中变为保护权限
        m_B = 100; // 父类中保护成员，到子类中还是保护权限
        // 子类访问不到父类的私有成员
    }
};

class Son3:private Base1
{
    public:
    void func()
    {
        m_A = 100; // 父类中公共成员，到子类中变为私有权限
        m_B = 100; // 父类中保护成员，到子类中变为私有权限
        // 子类访问不到父类的私有成员
    }
};

class GrandSon3: public Son3
{
    public:
    void func()
    {
        // m_A=100; 私有成员，子类不能访问
    }

};

void test01()
{
    Son1 son1;
    son1.m_A = 100; 
    // m_B 是保护权限，类外访问不到

    Son2 son2;
    // son2.m_A=100; 父类中公共成员，到子类中变为保护权限, 类外访问不到

    Son3 son3;
    // son3.m_A; 私有成员，类外不可访问

}

int main(int argc, char *argv[])
{
    test01();
}
```

#### 4.6.3 继承中的对象模型

```cpp
# include <iostream>
using namespace std;

class Base
{
    public:
    int m_A;

    protected:
    int m_B;

    private:
    int m_C;
};

class Son:public Base
{
    public:
    int m_D;
};


void test01()
{
    // 父类中所有非静态成员属性都会被子类继承下去
    // 父类中私有成员属性是被编译器隐藏了，因此访问不到，但是确实是被继承下去了。
    cout << "size of Son = " << sizeof(Son)<< endl;  // 16   

}

int main(int argc, char *argv[])
{
    test01();
}
```

#### 4.6.4 继承中构造和析构顺序

> 继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造顺序相反。

```cpp
# include <iostream>
using namespace std;

class Base
{
    public:
    int m_A;

    protected:
    int m_B;

    private:
    int m_C;

    public:
    Base()
    {
        cout << "父类构造函数！" <<endl;
    }
    ~Base()
    {
        cout << "父类析构函数！" <<endl;
    }
};

class Son:public Base
{
    public:
    int m_D;

    public:
    Son()
    {
        cout << "子类构造函数！" <<endl;
    }
    ~Son()
    {
        cout << "子类析构函数！" <<endl;
    }
};


void test01()
{
    Son son; 
    // 父类构造函数！
    // 子类构造函数！
    // 子类析构函数！
    // 父类析构函数！

    // 根据系统输出可知
    // 继承中的构造的析构顺序如下
    // 先构造父类，再构造子类。先析构子类，再析构父类

}

int main(int argc, char *argv[])
{
    test01();
}
```

#### 4.6.5 继承同名成员处理方式

- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加载作用域

